/**
 * @file test_oil_pressure_sensor.cpp
 * @brief Comprehensive unit tests for OilPressureSensor class
 * 
 * @details Tests all aspects of oil pressure sensor functionality including:
 * - Initialization and configuration
 * - ADC value to pressure mapping (0-4095 → 0-10 Bar)
 * - Delta-based updates (only on value change)
 * - Time-based sampling (1Hz frequency)
 * - Boundary conditions and error handling
 * 
 * Success Criteria:
 * - 100% test pass rate
 * - All boundary conditions covered
 * - Delta-based update behavior verified
 * - Time-based sampling validated
 * - Hardware abstraction properly tested
 */

#include "unity.h"
#include "unity_config.h"
#include "sensors/oil_pressure_sensor.h"
#include "mocks/mock_gpio_provider.h"
#include "utilities/test_helpers.h"
#include "hardware/gpio_pins.h"
#include <memory>
#include <thread>
#include <chrono>

// Test fixture globals
static std::unique_ptr<MockGpioProvider> mockGpio;
static std::unique_ptr<OilPressureSensor> sensor;

void setUp(void) {
    // Create fresh mock and sensor for each test
    mockGpio = TestHelpers::createMockGpioProvider();
    sensor = std::make_unique<OilPressureSensor>(mockGpio.get());
}

void tearDown(void) {
    // Clean up after each test
    sensor.reset();
    mockGpio.reset();
}

// ============================================================================
// INITIALIZATION TESTS
// ============================================================================

void test_oil_pressure_sensor_initialization() {
    // Given: Fresh sensor and mock
    // When: Sensor is initialized
    sensor->init();
    
    // Then: No crashes occur and sensor is ready
    Reading reading = sensor->getReading();
    TEST_ASSERT_FALSE(std::holds_alternative<std::monostate>(reading));
    
    // Verify GPIO configuration was called
    TEST_ASSERT_TRUE(mockGpio->getAnalogReadCount(gpio_pins::OIL_PRESSURE) > 0);
}

void test_oil_pressure_sensor_constructor() {
    // Given: Valid GPIO provider
    // When: Sensor is constructed
    OilPressureSensor testSensor(mockGpio.get());
    
    // Then: Construction succeeds without throwing
    TEST_ASSERT_NOT_NULL(&testSensor);
}

void test_oil_pressure_sensor_null_gpio_provider() {
    // Given: Null GPIO provider
    // When: Sensor is constructed
    // Then: Should handle gracefully (implementation dependent)
    // Note: This test depends on implementation - may crash or handle gracefully
    // For now, we trust the constructor contract
}

// ============================================================================
// ADC VALUE MAPPING TESTS
// ============================================================================

void test_oil_pressure_sensor_adc_mapping_minimum() {
    // Given: ADC value at minimum (0)
    TestHelpers::configureMockForOilPressure(mockGpio.get(), 0);
    sensor->init();
    
    // When: Reading is obtained
    Reading reading = sensor->getReading();
    
    // Then: Pressure should be 0 Bar
    int32_t expectedPressure = TestHelpers::calculateExpectedPressure(0);
    TestHelpers::assertReadingInt32(reading, expectedPressure);
    TEST_ASSERT_EQUAL_INT32(0, expectedPressure);
}

void test_oil_pressure_sensor_adc_mapping_maximum() {
    // Given: ADC value at maximum (4095)
    TestHelpers::configureMockForOilPressure(mockGpio.get(), 4095);
    sensor->init();
    
    // When: Reading is obtained
    Reading reading = sensor->getReading();
    
    // Then: Pressure should be 10 Bar
    int32_t expectedPressure = TestHelpers::calculateExpectedPressure(4095);
    TestHelpers::assertReadingInt32(reading, expectedPressure);
    TEST_ASSERT_EQUAL_INT32(10, expectedPressure);
}

void test_oil_pressure_sensor_adc_mapping_midpoint() {
    // Given: ADC value at midpoint (2047-2048)
    uint16_t midpointAdc = 2048;
    TestHelpers::configureMockForOilPressure(mockGpio.get(), midpointAdc);
    sensor->init();
    
    // When: Reading is obtained
    Reading reading = sensor->getReading();
    
    // Then: Pressure should be approximately 5 Bar
    int32_t expectedPressure = TestHelpers::calculateExpectedPressure(midpointAdc);
    TestHelpers::assertReadingInt32(reading, expectedPressure);
    TestHelpers::assertValidPressureRange(expectedPressure);
    
    // Verify it's close to expected midpoint (within ±1 due to integer math)
    TEST_ASSERT_TRUE(expectedPressure >= 4 && expectedPressure <= 5);
}

void test_oil_pressure_sensor_adc_mapping_quarter_points() {
    // Test quarter points to verify linear mapping
    
    // First quarter (25%)
    uint16_t quarterAdc = 1024;  // 25% of 4095
    TestHelpers::configureMockForOilPressure(mockGpio.get(), quarterAdc);
    sensor->init();
    Reading reading1 = sensor->getReading();
    int32_t pressure1 = std::get<int32_t>(reading1);
    TestHelpers::assertValidPressureRange(pressure1);
    
    // Third quarter (75%)
    uint16_t threeQuarterAdc = 3072;  // 75% of 4095
    mockGpio->setAnalogReading(gpio_pins::OIL_PRESSURE, threeQuarterAdc);
    TestHelpers::waitForSensorUpdate(1000);
    Reading reading2 = sensor->getReading();
    int32_t pressure2 = std::get<int32_t>(reading2);
    TestHelpers::assertValidPressureRange(pressure2);
    
    // Verify linear relationship (pressure2 should be ~3x pressure1)
    TEST_ASSERT_TRUE(pressure2 > pressure1);
}

// ============================================================================
// DELTA-BASED UPDATE TESTS
// ============================================================================

void test_oil_pressure_sensor_delta_based_updates_same_value() {
    // Given: Sensor initialized with specific ADC value
    uint16_t adcValue = 2048;
    TestHelpers::configureMockForOilPressure(mockGpio.get(), adcValue);
    sensor->init();
    
    // When: Multiple readings are taken without changing ADC value
    Reading reading1 = sensor->getReading();
    Reading reading2 = sensor->getReading();
    Reading reading3 = sensor->getReading();
    
    // Then: All readings should be identical
    int32_t pressure1 = std::get<int32_t>(reading1);
    int32_t pressure2 = std::get<int32_t>(reading2);
    int32_t pressure3 = std::get<int32_t>(reading3);
    
    TEST_ASSERT_EQUAL_INT32(pressure1, pressure2);
    TEST_ASSERT_EQUAL_INT32(pressure2, pressure3);
}

void test_oil_pressure_sensor_delta_based_updates_value_change() {
    // Given: Sensor initialized with initial ADC value
    TestHelpers::configureMockForOilPressure(mockGpio.get(), 1000);
    sensor->init();
    Reading initialReading = sensor->getReading();
    int32_t initialPressure = std::get<int32_t>(initialReading);
    
    // When: ADC value changes and sufficient time passes
    mockGpio->setAnalogReading(gpio_pins::OIL_PRESSURE, 3000);
    TestHelpers::waitForSensorUpdate(1000);
    
    // Then: New reading should reflect changed value
    Reading newReading = sensor->getReading();
    int32_t newPressure = std::get<int32_t>(newReading);
    
    TEST_ASSERT_NOT_EQUAL(initialPressure, newPressure);
    TEST_ASSERT_TRUE(newPressure > initialPressure);
}

void test_oil_pressure_sensor_delta_based_updates_no_time_passage() {
    // Given: Sensor initialized
    TestHelpers::configureMockForOilPressure(mockGpio.get(), 1000);
    sensor->init();
    Reading initialReading = sensor->getReading();
    
    // When: ADC value changes but insufficient time passes
    mockGpio->setAnalogReading(gpio_pins::OIL_PRESSURE, 3000);
    // No time advancement - should use cached value
    
    // Then: Reading should still be cached value
    Reading quickReading = sensor->getReading();
    
    TEST_ASSERT_EQUAL_INT32(std::get<int32_t>(initialReading), 
                           std::get<int32_t>(quickReading));
}

// ============================================================================
// TIME-BASED SAMPLING TESTS
// ============================================================================

void test_oil_pressure_sensor_time_based_sampling_frequency() {
    // Given: Sensor with changing ADC values
    std::vector<uint16_t> adcSequence = {1000, 1500, 2000, 2500, 3000};
    mockGpio->setAnalogReadingSequence(gpio_pins::OIL_PRESSURE, adcSequence);
    sensor->init();
    
    // When: Readings are taken at update intervals
    std::vector<int32_t> pressureReadings;
    
    for (int i = 0; i < 5; i++) {
        Reading reading = sensor->getReading();
        pressureReadings.push_back(std::get<int32_t>(reading));
        
        if (i < 4) { // Don't wait after last reading
            TestHelpers::waitForSensorUpdate(1000);
        }
    }
    
    // Then: Each reading should be different (following the sequence)
    for (size_t i = 1; i < pressureReadings.size(); i++) {
        TEST_ASSERT_NOT_EQUAL(pressureReadings[i-1], pressureReadings[i]);
        // Each should be higher than previous (increasing sequence)
        TEST_ASSERT_TRUE(pressureReadings[i] > pressureReadings[i-1]);
    }
}

void test_oil_pressure_sensor_time_based_sampling_update_interval() {
    // Given: Sensor initialized
    TestHelpers::configureMockForOilPressure(mockGpio.get(), 1000);
    sensor->init();
    
    // Record initial read count
    int initialReadCount = mockGpio->getAnalogReadCount(gpio_pins::OIL_PRESSURE);
    
    // When: Multiple readings are requested rapidly (< 1000ms apart)
    sensor->getReading();
    sensor->getReading();
    sensor->getReading();
    
    // Then: GPIO should not be read multiple times (caching)
    int rapidReadCount = mockGpio->getAnalogReadCount(gpio_pins::OIL_PRESSURE);
    TEST_ASSERT_EQUAL_INT(initialReadCount, rapidReadCount);
    
    // When: Sufficient time passes and reading is requested
    TestHelpers::waitForSensorUpdate(1000);
    sensor->getReading();
    
    // Then: GPIO should be read again
    int delayedReadCount = mockGpio->getAnalogReadCount(gpio_pins::OIL_PRESSURE);
    TEST_ASSERT_TRUE(delayedReadCount > rapidReadCount);
}

// ============================================================================
// BOUNDARY CONDITION TESTS
// ============================================================================

void test_oil_pressure_sensor_boundary_adc_zero() {
    // Test explicit zero ADC value
    TestHelpers::configureMockForOilPressure(mockGpio.get(), 0);
    sensor->init();
    
    Reading reading = sensor->getReading();
    int32_t pressure = std::get<int32_t>(reading);
    
    TEST_ASSERT_EQUAL_INT32(0, pressure);
    TestHelpers::assertValidPressureRange(pressure);
}

void test_oil_pressure_sensor_boundary_adc_max() {
    // Test maximum ADC value
    TestHelpers::configureMockForOilPressure(mockGpio.get(), 4095);
    sensor->init();
    
    Reading reading = sensor->getReading();
    int32_t pressure = std::get<int32_t>(reading);
    
    TEST_ASSERT_EQUAL_INT32(10, pressure);
    TestHelpers::assertValidPressureRange(pressure);
}

void test_oil_pressure_sensor_boundary_pressure_ranges() {
    // Test various pressure ranges to ensure all are valid
    std::vector<uint16_t> testAdcValues = {0, 409, 819, 1228, 1638, 2047, 2457, 2866, 3276, 3685, 4095};
    
    for (uint16_t adcValue : testAdcValues) {
        mockGpio->setAnalogReading(gpio_pins::OIL_PRESSURE, adcValue);
        TestHelpers::waitForSensorUpdate(1000);
        
        Reading reading = sensor->getReading();
        int32_t pressure = std::get<int32_t>(reading);
        
        TestHelpers::assertValidPressureRange(pressure);
        
        // Verify pressure correlates with ADC value
        int32_t expectedPressure = TestHelpers::calculateExpectedPressure(adcValue);
        TEST_ASSERT_EQUAL_INT32(expectedPressure, pressure);
    }
}

// ============================================================================
// ERROR CONDITION TESTS
// ============================================================================

void test_oil_pressure_sensor_gpio_pin_validation() {
    // Verify sensor uses correct GPIO pin
    sensor->init();
    sensor->getReading();
    
    // Should have read from oil pressure pin
    TEST_ASSERT_TRUE(mockGpio->getAnalogReadCount(gpio_pins::OIL_PRESSURE) > 0);
    
    // Should not have read from other pins
    TEST_ASSERT_EQUAL_INT(0, mockGpio->getAnalogReadCount(gpio_pins::OIL_TEMPERATURE));
    TEST_ASSERT_EQUAL_INT(0, mockGpio->getDigitalReadCount(gpio_pins::KEY_PRESENT));
}

void test_oil_pressure_sensor_multiple_initialization() {
    // Test that multiple init() calls don't cause issues
    sensor->init();
    Reading reading1 = sensor->getReading();
    
    sensor->init(); // Second initialization
    Reading reading2 = sensor->getReading();
    
    // Should still work correctly
    TEST_ASSERT_TRUE(std::holds_alternative<int32_t>(reading1));
    TEST_ASSERT_TRUE(std::holds_alternative<int32_t>(reading2));
}

// ============================================================================
// PERFORMANCE TESTS
// ============================================================================

void test_oil_pressure_sensor_performance_reading_speed() {
    // Given: Initialized sensor
    TestHelpers::configureMockForOilPressure(mockGpio.get(), 2048);
    sensor->init();
    
    // When: Multiple rapid readings are taken (should use cache)
    auto start = std::chrono::steady_clock::now();
    
    for (int i = 0; i < 100; i++) {
        Reading reading = sensor->getReading();
        TEST_ASSERT_TRUE(std::holds_alternative<int32_t>(reading));
    }
    
    auto end = std::chrono::steady_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    
    // Then: Should complete quickly (< 1ms total for 100 reads due to caching)
    TEST_ASSERT_TRUE(duration.count() < 1000); // Less than 1ms
}

void test_oil_pressure_sensor_memory_usage() {
    // Verify no memory leaks during operation
    TEST_ASSERT_NO_MEMORY_LEAK();
    
    // Create and destroy multiple sensors
    for (int i = 0; i < 10; i++) {
        auto testMock = TestHelpers::createMockGpioProvider();
        OilPressureSensor testSensor(testMock.get());
        testSensor.init();
        testSensor.getReading();
    }
    
    TEST_ASSERT_NO_MEMORY_LEAK();
}

// ============================================================================
// INTEGRATION TESTS
// ============================================================================

void test_oil_pressure_sensor_realistic_scenario() {
    // Simulate realistic oil pressure changes during engine operation
    
    // Engine start: Low pressure
    TestHelpers::configureMockForOilPressure(mockGpio.get(), 819); // ~2 Bar
    sensor->init();
    Reading startReading = sensor->getReading();
    int32_t startPressure = std::get<int32_t>(startReading);
    TEST_ASSERT_TRUE(startPressure >= 1 && startPressure <= 3);
    
    // Engine warm-up: Increasing pressure
    mockGpio->setAnalogReading(gpio_pins::OIL_PRESSURE, 2047); // ~5 Bar
    TestHelpers::waitForSensorUpdate(1000);
    Reading warmupReading = sensor->getReading();
    int32_t warmupPressure = std::get<int32_t>(warmupReading);
    TEST_ASSERT_TRUE(warmupPressure > startPressure);
    
    // Normal operation: Stable high pressure
    mockGpio->setAnalogReading(gpio_pins::OIL_PRESSURE, 3276); // ~8 Bar
    TestHelpers::waitForSensorUpdate(1000);
    Reading normalReading = sensor->getReading();
    int32_t normalPressure = std::get<int32_t>(normalReading);
    TEST_ASSERT_TRUE(normalPressure > warmupPressure);
    TEST_ASSERT_TRUE(normalPressure >= 7 && normalPressure <= 9);
}

// ============================================================================
// TEST RUNNER SETUP
// ============================================================================

void runOilPressureSensorTests() {
    RUN_TEST(test_oil_pressure_sensor_initialization);
    RUN_TEST(test_oil_pressure_sensor_constructor);
    
    RUN_TEST(test_oil_pressure_sensor_adc_mapping_minimum);
    RUN_TEST(test_oil_pressure_sensor_adc_mapping_maximum);
    RUN_TEST(test_oil_pressure_sensor_adc_mapping_midpoint);
    RUN_TEST(test_oil_pressure_sensor_adc_mapping_quarter_points);
    
    RUN_TEST(test_oil_pressure_sensor_delta_based_updates_same_value);
    RUN_TEST(test_oil_pressure_sensor_delta_based_updates_value_change);
    RUN_TEST(test_oil_pressure_sensor_delta_based_updates_no_time_passage);
    
    RUN_TEST(test_oil_pressure_sensor_time_based_sampling_frequency);
    RUN_TEST(test_oil_pressure_sensor_time_based_sampling_update_interval);
    
    RUN_TEST(test_oil_pressure_sensor_boundary_adc_zero);
    RUN_TEST(test_oil_pressure_sensor_boundary_adc_max);
    RUN_TEST(test_oil_pressure_sensor_boundary_pressure_ranges);
    
    RUN_TEST(test_oil_pressure_sensor_gpio_pin_validation);
    RUN_TEST(test_oil_pressure_sensor_multiple_initialization);
    
    RUN_TEST(test_oil_pressure_sensor_performance_reading_speed);
    RUN_TEST(test_oil_pressure_sensor_memory_usage);
    
    RUN_TEST(test_oil_pressure_sensor_realistic_scenario);
}

#ifdef UNITY_MAIN
int main() {
    UNITY_BEGIN();
    runOilPressureSensorTests();
    return UNITY_END();
}
#endif