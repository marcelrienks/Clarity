/**
 * @file test_light_sensor.cpp
 * @brief Comprehensive unit tests for LightSensor class
 * 
 * @details Tests all aspects of light sensor functionality including:
 * - Initialization and GPIO configuration
 * - Digital input reading (lights on/off states)
 * - Boolean output verification
 * - Pin mode configuration
 * - State change detection
 * - Theme switching trigger support
 * - Direct state access methods
 * 
 * Success Criteria:
 * - 100% test pass rate
 * - All light states covered (on/off)
 * - GPIO configuration properly tested
 * - Direct state method consistency
 * - Performance requirements met
 * - Hardware abstraction validated
 */

#include "unity.h"
#include "unity_config.h"
#include "sensors/light_sensor.h"
#include "mocks/mock_gpio_provider.h"
#include "utilities/test_helpers.h"
#include "hardware/gpio_pins.h"
#include <memory>
#include <thread>
#include <chrono>

// Test fixture globals
static std::unique_ptr<MockGpioProvider> mockGpio;
static std::unique_ptr<LightSensor> sensor;

void setUp(void) {
    // Create fresh mock and sensor for each test
    mockGpio = TestHelpers::createMockGpioProvider();
    sensor = std::make_unique<LightSensor>(mockGpio.get());
}

void tearDown(void) {
    // Clean up after each test
    sensor.reset();
    mockGpio.reset();
}

// ============================================================================
// INITIALIZATION TESTS
// ============================================================================

void test_light_sensor_initialization() {
    // Given: Fresh sensor and mock
    // When: Sensor is initialized
    sensor->init();
    
    // Then: GPIO pin should be configured properly
    TEST_ASSERT_TRUE(mockGpio->wasPinModeSet(gpio_pins::LIGHTS));
    
    // Verify pin mode is set to INPUT_PULLDOWN
    TEST_ASSERT_EQUAL_INT(INPUT_PULLDOWN, mockGpio->getPinMode(gpio_pins::LIGHTS));
    
    // Sensor should be ready to provide readings
    Reading reading = sensor->getReading();
    TEST_ASSERT_FALSE(std::holds_alternative<std::monostate>(reading));
    TEST_ASSERT_TRUE(std::holds_alternative<bool>(reading));
}

void test_light_sensor_constructor() {
    // Given: Valid GPIO provider
    // When: Sensor is constructed
    LightSensor testSensor(mockGpio.get());
    
    // Then: Construction succeeds without throwing
    TEST_ASSERT_NOT_NULL(&testSensor);
}

void test_light_sensor_pin_mode_configuration() {
    // Given: Fresh sensor
    // When: Sensor is initialized
    sensor->init();
    
    // Then: Lights pin should be configured as INPUT_PULLDOWN
    TEST_ASSERT_EQUAL_INT(INPUT_PULLDOWN, mockGpio->getPinMode(gpio_pins::LIGHTS));
    
    // Verify pinMode was actually called
    TEST_ASSERT_TRUE(mockGpio->wasPinModeSet(gpio_pins::LIGHTS));
}

// ============================================================================
// LIGHT STATE TESTS
// ============================================================================

void test_light_sensor_lights_on_state() {
    // Given: Lights pin HIGH (lights on)
    TestHelpers::configureMockForLightSensor(mockGpio.get(), true);
    sensor->init();
    
    // When: Reading is obtained
    Reading reading = sensor->getReading();
    bool directState = sensor->getLightsState();
    
    // Then: Should return true (lights on)
    TEST_ASSERT_TRUE(std::holds_alternative<bool>(reading));
    TestHelpers::assertReadingBool(reading, true);
    TEST_ASSERT_TRUE(directState);
}

void test_light_sensor_lights_off_state() {
    // Given: Lights pin LOW (lights off)
    TestHelpers::configureMockForLightSensor(mockGpio.get(), false);
    sensor->init();
    
    // When: Reading is obtained
    Reading reading = sensor->getReading();
    bool directState = sensor->getLightsState();
    
    // Then: Should return false (lights off)
    TEST_ASSERT_TRUE(std::holds_alternative<bool>(reading));
    TestHelpers::assertReadingBool(reading, false);
    TEST_ASSERT_FALSE(directState);
}

// ============================================================================
// STATE TRANSITION TESTS
// ============================================================================

void test_light_sensor_state_transition_off_to_on() {
    // Given: Initial state is lights off (day time)
    TestHelpers::configureMockForLightSensor(mockGpio.get(), false);
    sensor->init();
    Reading initialReading = sensor->getReading();
    bool initialState = sensor->getLightsState();
    TestHelpers::assertReadingBool(initialReading, false);
    TEST_ASSERT_FALSE(initialState);
    
    // When: Lights turn on (night time)
    TestHelpers::configureMockForLightSensor(mockGpio.get(), true);
    Reading newReading = sensor->getReading();
    bool newState = sensor->getLightsState();
    
    // Then: Reading should change to lights on
    TestHelpers::assertReadingBool(newReading, true);
    TEST_ASSERT_TRUE(newState);
    TEST_ASSERT_NOT_EQUAL(std::get<bool>(initialReading), std::get<bool>(newReading));
    TEST_ASSERT_NOT_EQUAL(initialState, newState);
}

void test_light_sensor_state_transition_on_to_off() {
    // Given: Initial state is lights on (night time)
    TestHelpers::configureMockForLightSensor(mockGpio.get(), true);
    sensor->init();
    Reading initialReading = sensor->getReading();
    bool initialState = sensor->getLightsState();
    TestHelpers::assertReadingBool(initialReading, true);
    TEST_ASSERT_TRUE(initialState);
    
    // When: Lights turn off (day time)
    TestHelpers::configureMockForLightSensor(mockGpio.get(), false);
    Reading newReading = sensor->getReading();
    bool newState = sensor->getLightsState();
    
    // Then: Reading should change to lights off
    TestHelpers::assertReadingBool(newReading, false);
    TEST_ASSERT_FALSE(newState);
    TEST_ASSERT_NOT_EQUAL(std::get<bool>(initialReading), std::get<bool>(newReading));
    TEST_ASSERT_NOT_EQUAL(initialState, newState);
}

void test_light_sensor_rapid_state_changes() {
    // Test rapid state changes to verify stability (e.g., driving through tunnel)
    sensor->init();
    
    // Simulate rapid light changes
    std::vector<bool> testStates = {false, true, false, true, true, false, true, false};
    
    for (bool lightState : testStates) {
        TestHelpers::configureMockForLightSensor(mockGpio.get(), lightState);
        Reading reading = sensor->getReading();
        bool directState = sensor->getLightsState();
        
        // Each reading should correctly reflect the current state
        TestHelpers::assertReadingBool(reading, lightState);
        TEST_ASSERT_EQUAL(lightState, directState);
    }
}

// ============================================================================
// METHOD CONSISTENCY TESTS
// ============================================================================

void test_light_sensor_getReading_vs_getLightsState_consistency() {
    // Test that getReading() and getLightsState() return consistent values
    sensor->init();
    
    // Test both states
    std::vector<bool> testStates = {true, false, true, false};
    
    for (bool expectedState : testStates) {
        TestHelpers::configureMockForLightSensor(mockGpio.get(), expectedState);
        
        Reading reading = sensor->getReading();
        bool directState = sensor->getLightsState();
        
        // Both methods should return the same state value
        TEST_ASSERT_TRUE(std::holds_alternative<bool>(reading));
        TEST_ASSERT_EQUAL(expectedState, std::get<bool>(reading));
        TEST_ASSERT_EQUAL(expectedState, directState);
        TEST_ASSERT_EQUAL(std::get<bool>(reading), directState);
    }
}

void test_light_sensor_multiple_readings_same_state() {
    // Test that multiple readings with same pin state return consistent results
    TestHelpers::configureMockForLightSensor(mockGpio.get(), true);
    sensor->init();
    
    // Take multiple readings using both methods
    std::vector<Reading> readings;
    std::vector<bool> directStates;
    
    for (int i = 0; i < 5; i++) {
        readings.push_back(sensor->getReading());
        directStates.push_back(sensor->getLightsState());
    }
    
    // All should be identical
    for (size_t i = 1; i < readings.size(); i++) {
        TEST_ASSERT_EQUAL(std::get<bool>(readings[0]), std::get<bool>(readings[i]));
        TEST_ASSERT_EQUAL(directStates[0], directStates[i]);
    }
    
    // All should be true (lights on)
    for (const auto& reading : readings) {
        TestHelpers::assertReadingBool(reading, true);
    }
    for (bool state : directStates) {
        TEST_ASSERT_TRUE(state);
    }
}

// ============================================================================
// GPIO PIN VALIDATION TESTS
// ============================================================================

void test_light_sensor_gpio_pin_usage() {
    // Given: Initialized sensor
    sensor->init();
    
    // When: Reading is obtained
    sensor->getReading();
    sensor->getLightsState();
    
    // Then: Should have read from lights pin
    TEST_ASSERT_TRUE(mockGpio->getDigitalReadCount(gpio_pins::LIGHTS) > 0);
    
    // Should not have read from other pins
    TEST_ASSERT_EQUAL_INT(0, mockGpio->getDigitalReadCount(gpio_pins::KEY_PRESENT));
    TEST_ASSERT_EQUAL_INT(0, mockGpio->getDigitalReadCount(gpio_pins::KEY_NOT_PRESENT));
    TEST_ASSERT_EQUAL_INT(0, mockGpio->getDigitalReadCount(gpio_pins::LOCK));
    TEST_ASSERT_EQUAL_INT(0, mockGpio->getAnalogReadCount(gpio_pins::OIL_PRESSURE));
    TEST_ASSERT_EQUAL_INT(0, mockGpio->getAnalogReadCount(gpio_pins::OIL_TEMPERATURE));
}

void test_light_sensor_correct_pin_number() {
    // Verify sensor uses the correct GPIO pin number
    sensor->init();
    sensor->getReading();
    
    // Should have accessed the LIGHTS pin specifically
    TEST_ASSERT_TRUE(mockGpio->getDigitalReadCount(gpio_pins::LIGHTS) > 0);
    
    // Verify the pin number is as expected (from gpio_pins.h: LIGHTS = 33)
    TEST_ASSERT_EQUAL_INT(33, gpio_pins::LIGHTS);
}

void test_light_sensor_pin_read_count() {
    // Test that getLightsState() method also reads the pin
    TestHelpers::configureMockForLightSensor(mockGpio.get(), false);
    sensor->init();
    
    int initialReadCount = mockGpio->getDigitalReadCount(gpio_pins::LIGHTS);
    
    // Call both methods
    sensor->getReading();
    sensor->getLightsState();
    
    int finalReadCount = mockGpio->getDigitalReadCount(gpio_pins::LIGHTS);
    
    // Should have made at least 2 additional reads
    TEST_ASSERT_TRUE((finalReadCount - initialReadCount) >= 2);
}

// ============================================================================
// THEME SWITCHING CONTEXT TESTS
// ============================================================================

void test_light_sensor_day_time_scenario() {
    // Test day time scenario (lights off -> day theme)
    TestHelpers::configureMockForLightSensor(mockGpio.get(), false);
    sensor->init();
    
    Reading reading = sensor->getReading();
    bool lightsState = sensor->getLightsState();
    
    // Day time: lights should be off
    TestHelpers::assertReadingBool(reading, false);
    TEST_ASSERT_FALSE(lightsState);
    
    // This would trigger day theme in the actual system
}

void test_light_sensor_night_time_scenario() {
    // Test night time scenario (lights on -> night theme)
    TestHelpers::configureMockForLightSensor(mockGpio.get(), true);
    sensor->init();
    
    Reading reading = sensor->getReading();
    bool lightsState = sensor->getLightsState();
    
    // Night time: lights should be on
    TestHelpers::assertReadingBool(reading, true);
    TEST_ASSERT_TRUE(lightsState);
    
    // This would trigger night theme in the actual system
}

void test_light_sensor_theme_transition_simulation() {
    // Simulate day-to-night-to-day transition
    sensor->init();
    
    // Day time
    TestHelpers::configureMockForLightSensor(mockGpio.get(), false);
    bool dayState = sensor->getLightsState();
    TEST_ASSERT_FALSE(dayState); // Should trigger day theme
    
    // Evening (lights turn on)
    TestHelpers::configureMockForLightSensor(mockGpio.get(), true);
    bool nightState = sensor->getLightsState();
    TEST_ASSERT_TRUE(nightState); // Should trigger night theme
    
    // Morning (lights turn off)
    TestHelpers::configureMockForLightSensor(mockGpio.get(), false);
    bool morningState = sensor->getLightsState();
    TEST_ASSERT_FALSE(morningState); // Should trigger day theme again
    
    // Verify transitions occurred
    TEST_ASSERT_NOT_EQUAL(dayState, nightState);
    TEST_ASSERT_NOT_EQUAL(nightState, morningState);
    TEST_ASSERT_EQUAL(dayState, morningState);
}

// ============================================================================
// BOUNDARY AND EDGE CASE TESTS
// ============================================================================

void test_light_sensor_pin_state_boundary_values() {
    // Test explicit HIGH state
    mockGpio->setDigitalReading(gpio_pins::LIGHTS, true);
    sensor->init();
    Reading highReading = sensor->getReading();
    TestHelpers::assertReadingBool(highReading, true);
    
    // Test explicit LOW state
    mockGpio->setDigitalReading(gpio_pins::LIGHTS, false);
    Reading lowReading = sensor->getReading();
    TestHelpers::assertReadingBool(lowReading, false);
}

void test_light_sensor_multiple_initialization() {
    // Test that multiple init() calls don't cause issues
    sensor->init();
    Reading reading1 = sensor->getReading();
    bool state1 = sensor->getLightsState();
    
    sensor->init(); // Second initialization
    Reading reading2 = sensor->getReading();
    bool state2 = sensor->getLightsState();
    
    // Should still work correctly
    TEST_ASSERT_TRUE(std::holds_alternative<bool>(reading1));
    TEST_ASSERT_TRUE(std::holds_alternative<bool>(reading2));
    
    // Results should be consistent
    TEST_ASSERT_EQUAL(std::get<bool>(reading1), std::get<bool>(reading2));
    TEST_ASSERT_EQUAL(state1, state2);
}

void test_light_sensor_initialization_without_prior_pin_setup() {
    // Test initialization on fresh mock (no prior pin configuration)
    auto freshMock = TestHelpers::createMockGpioProvider();
    LightSensor freshSensor(freshMock.get());
    
    // Should initialize successfully
    freshSensor.init();
    Reading reading = freshSensor.getReading();
    bool state = freshSensor.getLightsState();
    
    // Should provide valid boolean readings
    TEST_ASSERT_TRUE(std::holds_alternative<bool>(reading));
    // state should be false (default) or true based on mock default
}

// ============================================================================
// PERFORMANCE TESTS
// ============================================================================

void test_light_sensor_performance_reading_speed() {
    // Given: Initialized sensor
    TestHelpers::configureMockForLightSensor(mockGpio.get(), true);
    sensor->init();
    
    // When: Multiple rapid readings are taken
    auto start = std::chrono::steady_clock::now();
    
    for (int i = 0; i < 100; i++) {
        Reading reading = sensor->getReading();
        bool state = sensor->getLightsState();
        TEST_ASSERT_TRUE(std::holds_alternative<bool>(reading));
        // Use state to avoid unused variable warning
        (void)state;
    }
    
    auto end = std::chrono::steady_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    
    // Then: Should complete quickly (< 2ms total for 200 operations)
    TEST_ASSERT_TRUE(duration.count() < 2000); // Less than 2ms
}

void test_light_sensor_gpio_read_efficiency() {
    // Test GPIO read efficiency for both methods
    TestHelpers::configureMockForLightSensor(mockGpio.get(), false);
    sensor->init();
    
    int initialReadCount = mockGpio->getDigitalReadCount(gpio_pins::LIGHTS);
    
    // Make calls to both methods
    sensor->getReading();
    sensor->getLightsState();
    
    int finalReadCount = mockGpio->getDigitalReadCount(gpio_pins::LIGHTS);
    
    // Should have made exactly 2 additional reads (one per method call)
    TEST_ASSERT_EQUAL_INT(2, finalReadCount - initialReadCount);
}

void test_light_sensor_memory_usage() {
    // Verify no memory leaks during operation
    TEST_ASSERT_NO_MEMORY_LEAK();
    
    // Create and destroy multiple sensors
    for (int i = 0; i < 10; i++) {
        auto testMock = TestHelpers::createMockGpioProvider();
        LightSensor testSensor(testMock.get());
        testSensor.init();
        testSensor.getReading();
        testSensor.getLightsState();
    }
    
    TEST_ASSERT_NO_MEMORY_LEAK();
}

// ============================================================================
// INTEGRATION TESTS
// ============================================================================

void test_light_sensor_realistic_driving_scenario() {
    // Simulate realistic driving scenario with light changes
    sensor->init();
    
    // Morning: Start with lights off (day time)
    TestHelpers::configureMockForLightSensor(mockGpio.get(), false);
    bool morningState = sensor->getLightsState();
    TEST_ASSERT_FALSE(morningState);
    
    // Enter tunnel: Lights turn on automatically
    TestHelpers::configureMockForLightSensor(mockGpio.get(), true);
    bool tunnelState = sensor->getLightsState();
    TEST_ASSERT_TRUE(tunnelState);
    
    // Exit tunnel: Lights turn off
    TestHelpers::configureMockForLightSensor(mockGpio.get(), false);
    bool postTunnelState = sensor->getLightsState();
    TEST_ASSERT_FALSE(postTunnelState);
    
    // Evening: Lights turn on for night driving
    TestHelpers::configureMockForLightSensor(mockGpio.get(), true);
    bool eveningState = sensor->getLightsState();
    TEST_ASSERT_TRUE(eveningState);
    
    // Verify state transitions occurred correctly
    TEST_ASSERT_NOT_EQUAL(morningState, tunnelState);
    TEST_ASSERT_EQUAL(morningState, postTunnelState);
    TEST_ASSERT_EQUAL(tunnelState, eveningState);
}

void test_light_sensor_automatic_headlight_simulation() {
    // Test behavior with automatic headlight systems
    sensor->init();
    
    // Automatic headlights respond to ambient light
    std::vector<bool> lightConditions = {
        false, // Bright daylight
        false, // Overcast but bright
        true,  // Dusk - lights turn on
        true,  // Night driving
        true,  // Late night
        false, // Dawn - lights turn off
        false  // Morning daylight
    };
    
    for (size_t i = 0; i < lightConditions.size(); i++) {
        TestHelpers::configureMockForLightSensor(mockGpio.get(), lightConditions[i]);
        
        Reading reading = sensor->getReading();
        bool state = sensor->getLightsState();
        
        TestHelpers::assertReadingBool(reading, lightConditions[i]);
        TEST_ASSERT_EQUAL(lightConditions[i], state);
        
        // Log the condition for debugging if needed
        // printf("Condition %zu: Lights %s\n", i, lightConditions[i] ? "ON" : "OFF");
    }
}

void test_light_sensor_trigger_system_integration() {
    // Test integration with trigger system for theme switching
    sensor->init();
    
    // Test the pattern that would be used by trigger system
    
    // Initial state check
    TestHelpers::configureMockForLightSensor(mockGpio.get(), false);
    bool initialLightsState = sensor->getLightsState();
    
    // State change detection
    TestHelpers::configureMockForLightSensor(mockGpio.get(), true);
    bool newLightsState = sensor->getLightsState();
    
    // Trigger system would detect this change and switch themes
    if (initialLightsState != newLightsState) {
        if (newLightsState) {
            // Would trigger night theme
            TEST_ASSERT_TRUE(newLightsState);
        } else {
            // Would trigger day theme
            TEST_ASSERT_FALSE(newLightsState);
        }
    }
    
    TEST_ASSERT_NOT_EQUAL(initialLightsState, newLightsState);
}

// ============================================================================
// ERROR HANDLING TESTS
// ============================================================================

void test_light_sensor_gpio_provider_interaction() {
    // Test interaction with GPIO provider is correct
    sensor->init();
    
    // Verify correct method calls are made
    sensor->getReading();
    sensor->getLightsState();
    
    // Should have called digitalRead on lights pin
    TEST_ASSERT_TRUE(mockGpio->getDigitalReadCount(gpio_pins::LIGHTS) > 0);
    
    // Should have called pinMode during init
    TEST_ASSERT_TRUE(mockGpio->wasPinModeSet(gpio_pins::LIGHTS));
    
    // Should not have called analog functions
    TEST_ASSERT_EQUAL_INT(0, mockGpio->getAnalogReadCount(gpio_pins::LIGHTS));
}

void test_light_sensor_pin_mode_persistence() {
    // Test that pin mode remains configured after multiple readings
    sensor->init();
    
    // Take several readings with both methods
    for (int i = 0; i < 5; i++) {
        sensor->getReading();
        sensor->getLightsState();
        
        // Pin mode should remain INPUT_PULLDOWN
        TEST_ASSERT_EQUAL_INT(INPUT_PULLDOWN, mockGpio->getPinMode(gpio_pins::LIGHTS));
    }
}

// ============================================================================
// TEST RUNNER SETUP
// ============================================================================

void runLightSensorTests() {
    RUN_TEST(test_light_sensor_initialization);
    RUN_TEST(test_light_sensor_constructor);
    RUN_TEST(test_light_sensor_pin_mode_configuration);
    
    RUN_TEST(test_light_sensor_lights_on_state);
    RUN_TEST(test_light_sensor_lights_off_state);
    
    RUN_TEST(test_light_sensor_state_transition_off_to_on);
    RUN_TEST(test_light_sensor_state_transition_on_to_off);
    RUN_TEST(test_light_sensor_rapid_state_changes);
    
    RUN_TEST(test_light_sensor_getReading_vs_getLightsState_consistency);
    RUN_TEST(test_light_sensor_multiple_readings_same_state);
    
    RUN_TEST(test_light_sensor_gpio_pin_usage);
    RUN_TEST(test_light_sensor_correct_pin_number);
    RUN_TEST(test_light_sensor_pin_read_count);
    
    RUN_TEST(test_light_sensor_day_time_scenario);
    RUN_TEST(test_light_sensor_night_time_scenario);
    RUN_TEST(test_light_sensor_theme_transition_simulation);
    
    RUN_TEST(test_light_sensor_pin_state_boundary_values);
    RUN_TEST(test_light_sensor_multiple_initialization);
    RUN_TEST(test_light_sensor_initialization_without_prior_pin_setup);
    
    RUN_TEST(test_light_sensor_performance_reading_speed);
    RUN_TEST(test_light_sensor_gpio_read_efficiency);
    RUN_TEST(test_light_sensor_memory_usage);
    
    RUN_TEST(test_light_sensor_realistic_driving_scenario);
    RUN_TEST(test_light_sensor_automatic_headlight_simulation);
    RUN_TEST(test_light_sensor_trigger_system_integration);
    
    RUN_TEST(test_light_sensor_gpio_provider_interaction);
    RUN_TEST(test_light_sensor_pin_mode_persistence);
}

#ifdef UNITY_MAIN
int main() {
    UNITY_BEGIN();
    runLightSensorTests();
    return UNITY_END();  
}
#endif