/**
 * @file test_key_sensor.cpp
 * @brief Comprehensive unit tests for KeySensor class
 * 
 * @details Tests all aspects of key sensor functionality including:
 * - Initialization and GPIO configuration
 * - Digital input reading from two pins (present/not present)
 * - KeyState logic and invalid state handling
 * - Boolean output verification
 * - Pin mode configuration and interrupt setup
 * - State change detection and edge cases
 * 
 * Success Criteria:
 * - 100% test pass rate
 * - All state combinations covered (Present, NotPresent, Inactive)
 * - Invalid state handling verified
 * - GPIO configuration properly tested
 * - Interrupt setup validated
 */

#include "unity.h"
#include "unity_config.h"
#include "sensors/key_sensor.h"
#include "mocks/mock_gpio_provider.h"
#include "utilities/test_helpers.h"
#include "hardware/gpio_pins.h"
#include <memory>

// Test fixture globals
static std::unique_ptr<MockGpioProvider> mockGpio;
static std::unique_ptr<KeySensor> sensor;

void setUp(void) {
    // Create fresh mock and sensor for each test
    mockGpio = TestHelpers::createMockGpioProvider();
    sensor = std::make_unique<KeySensor>(mockGpio.get());
}

void tearDown(void) {
    // Clean up after each test
    sensor.reset();
    mockGpio.reset();
}

// ============================================================================
// INITIALIZATION TESTS
// ============================================================================

void test_key_sensor_initialization() {
    // Given: Fresh sensor and mock
    // When: Sensor is initialized
    sensor->init();
    
    // Then: GPIO pins should be configured properly
    TEST_ASSERT_TRUE(mockGpio->wasPinModeSet(gpio_pins::KEY_PRESENT));
    TEST_ASSERT_TRUE(mockGpio->wasPinModeSet(gpio_pins::KEY_NOT_PRESENT));
    
    // Verify pin modes are set to INPUT_PULLDOWN
    TEST_ASSERT_EQUAL_INT(INPUT_PULLDOWN, mockGpio->getPinMode(gpio_pins::KEY_PRESENT));
    TEST_ASSERT_EQUAL_INT(INPUT_PULLDOWN, mockGpio->getPinMode(gpio_pins::KEY_NOT_PRESENT));
    
    // Verify interrupts are attached
    TEST_ASSERT_TRUE(mockGpio->wasInterruptAttached(gpio_pins::KEY_PRESENT));
    TEST_ASSERT_TRUE(mockGpio->wasInterruptAttached(gpio_pins::KEY_NOT_PRESENT));
}

void test_key_sensor_constructor() {
    // Given: Valid GPIO provider
    // When: Sensor is constructed
    KeySensor testSensor(mockGpio.get());
    
    // Then: Construction succeeds without throwing
    TEST_ASSERT_NOT_NULL(&testSensor);
}

void test_key_sensor_interrupt_configuration() {
    // Given: Sensor to initialize
    // When: Sensor is initialized
    sensor->init();
    
    // Then: Interrupts should be configured with CHANGE mode
    TEST_ASSERT_EQUAL_INT(CHANGE, mockGpio->getInterruptMode(gpio_pins::KEY_PRESENT));
    TEST_ASSERT_EQUAL_INT(CHANGE, mockGpio->getInterruptMode(gpio_pins::KEY_NOT_PRESENT));
}

// ============================================================================
// KEY STATE LOGIC TESTS
// ============================================================================

void test_key_sensor_key_present_state() {
    // Given: Key present pin HIGH, key not present pin LOW
    TestHelpers::configureMockForKeySensor(mockGpio.get(), true, false);
    sensor->init();
    
    // When: Reading is obtained
    Reading reading = sensor->getReading();
    KeyState directState = sensor->getKeyState();
    
    // Then: Should return Present state
    TEST_ASSERT_TRUE(std::holds_alternative<int32_t>(reading));
    TEST_ASSERT_EQUAL_INT32(static_cast<int32_t>(KeyState::Present), std::get<int32_t>(reading));
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::Present), static_cast<int>(directState));
}

void test_key_sensor_key_not_present_state() {
    // Given: Key present pin LOW, key not present pin HIGH  
    TestHelpers::configureMockForKeySensor(mockGpio.get(), false, true);
    sensor->init();
    
    // When: Reading is obtained
    Reading reading = sensor->getReading();
    KeyState directState = sensor->getKeyState();
    
    // Then: Should return NotPresent state
    TEST_ASSERT_TRUE(std::holds_alternative<int32_t>(reading));
    TEST_ASSERT_EQUAL_INT32(static_cast<int32_t>(KeyState::NotPresent), std::get<int32_t>(reading));
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::NotPresent), static_cast<int>(directState));
}

void test_key_sensor_inactive_state_both_low() {
    // Given: Both pins LOW (no key detection)
    TestHelpers::configureMockForKeySensor(mockGpio.get(), false, false);
    sensor->init();
    
    // When: Reading is obtained
    Reading reading = sensor->getReading();
    KeyState directState = sensor->getKeyState();
    
    // Then: Should return Inactive state
    TEST_ASSERT_TRUE(std::holds_alternative<int32_t>(reading));
    TEST_ASSERT_EQUAL_INT32(static_cast<int32_t>(KeyState::Inactive), std::get<int32_t>(reading));
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::Inactive), static_cast<int>(directState));
}

void test_key_sensor_inactive_state_both_high() {
    // Given: Both pins HIGH (invalid/conflicting state)
    TestHelpers::configureMockForKeySensor(mockGpio.get(), true, true);
    sensor->init();
    
    // When: Reading is obtained
    Reading reading = sensor->getReading();
    KeyState directState = sensor->getKeyState();
    
    // Then: Should return Inactive state (graceful invalid state handling)
    TEST_ASSERT_TRUE(std::holds_alternative<int32_t>(reading));
    TEST_ASSERT_EQUAL_INT32(static_cast<int32_t>(KeyState::Inactive), std::get<int32_t>(reading));
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::Inactive), static_cast<int>(directState));
}

// ============================================================================
// STATE TRANSITION TESTS
// ============================================================================

void test_key_sensor_state_transitions_present_to_not_present() {
    // Given: Initial state is key present
    TestHelpers::configureMockForKeySensor(mockGpio.get(), true, false);
    sensor->init();
    KeyState initialState = sensor->getKeyState();
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::Present), static_cast<int>(initialState));
    
    // When: State changes to key not present
    TestHelpers::configureMockForKeySensor(mockGpio.get(), false, true);
    KeyState newState = sensor->getKeyState();
    
    // Then: State should change to NotPresent
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::NotPresent), static_cast<int>(newState));
    TEST_ASSERT_NOT_EQUAL(static_cast<int>(initialState), static_cast<int>(newState));
}

void test_key_sensor_state_transitions_not_present_to_present() {
    // Given: Initial state is key not present
    TestHelpers::configureMockForKeySensor(mockGpio.get(), false, true);
    sensor->init();
    KeyState initialState = sensor->getKeyState();
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::NotPresent), static_cast<int>(initialState));
    
    // When: State changes to key present
    TestHelpers::configureMockForKeySensor(mockGpio.get(), true, false);
    KeyState newState = sensor->getKeyState();
    
    // Then: State should change to Present
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::Present), static_cast<int>(newState));
    TEST_ASSERT_NOT_EQUAL(static_cast<int>(initialState), static_cast<int>(newState));
}

void test_key_sensor_state_transitions_to_inactive() {
    // Given: Initial state is key present
    TestHelpers::configureMockForKeySensor(mockGpio.get(), true, false);
    sensor->init();
    KeyState initialState = sensor->getKeyState();
    
    // When: Both pins go LOW (inactive)
    TestHelpers::configureMockForKeySensor(mockGpio.get(), false, false);
    KeyState newState = sensor->getKeyState();
    
    // Then: State should change to Inactive
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::Inactive), static_cast<int>(newState));
    TEST_ASSERT_NOT_EQUAL(static_cast<int>(initialState), static_cast<int>(newState));
}

void test_key_sensor_state_transitions_from_inactive() {
    // Given: Initial state is inactive
    TestHelpers::configureMockForKeySensor(mockGpio.get(), false, false);
    sensor->init();
    KeyState initialState = sensor->getKeyState();
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::Inactive), static_cast<int>(initialState));
    
    // When: Key present pin goes HIGH
    TestHelpers::configureMockForKeySensor(mockGpio.get(), true, false);
    KeyState newState = sensor->getKeyState();
    
    // Then: State should change to Present
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::Present), static_cast<int>(newState));
    TEST_ASSERT_NOT_EQUAL(static_cast<int>(initialState), static_cast<int>(newState));
}

// ============================================================================
// GPIO PIN VALIDATION TESTS
// ============================================================================

void test_key_sensor_gpio_pin_usage() {
    // Given: Initialized sensor
    sensor->init();
    
    // When: Reading is obtained
    sensor->getReading();
    
    // Then: Should have read from both key pins
    TEST_ASSERT_TRUE(mockGpio->getDigitalReadCount(gpio_pins::KEY_PRESENT) > 0);
    TEST_ASSERT_TRUE(mockGpio->getDigitalReadCount(gpio_pins::KEY_NOT_PRESENT) > 0);
    
    // Should not have read from other pins
    TEST_ASSERT_EQUAL_INT(0, mockGpio->getDigitalReadCount(gpio_pins::LOCK));
    TEST_ASSERT_EQUAL_INT(0, mockGpio->getDigitalReadCount(gpio_pins::LIGHTS));
    TEST_ASSERT_EQUAL_INT(0, mockGpio->getAnalogReadCount(gpio_pins::OIL_PRESSURE));
}

void test_key_sensor_pin_mode_configuration() {
    // Given: Fresh sensor
    // When: Sensor is initialized
    sensor->init();
    
    // Then: Both pins should be configured as INPUT_PULLDOWN
    TEST_ASSERT_EQUAL_INT(INPUT_PULLDOWN, mockGpio->getPinMode(gpio_pins::KEY_PRESENT));
    TEST_ASSERT_EQUAL_INT(INPUT_PULLDOWN, mockGpio->getPinMode(gpio_pins::KEY_NOT_PRESENT));
    
    // Verify pinMode was actually called
    TEST_ASSERT_TRUE(mockGpio->wasPinModeSet(gpio_pins::KEY_PRESENT));
    TEST_ASSERT_TRUE(mockGpio->wasPinModeSet(gpio_pins::KEY_NOT_PRESENT));
}

// ============================================================================
// INTERRUPT HANDLING TESTS
// ============================================================================

void test_key_sensor_interrupt_setup() {
    // Given: Fresh sensor
    // When: Sensor is initialized
    sensor->init();
    
    // Then: Interrupts should be attached to both pins
    TEST_ASSERT_TRUE(mockGpio->wasInterruptAttached(gpio_pins::KEY_PRESENT));
    TEST_ASSERT_TRUE(mockGpio->wasInterruptAttached(gpio_pins::KEY_NOT_PRESENT));
    
    // Both should be configured for CHANGE detection
    TEST_ASSERT_EQUAL_INT(CHANGE, mockGpio->getInterruptMode(gpio_pins::KEY_PRESENT));
    TEST_ASSERT_EQUAL_INT(CHANGE, mockGpio->getInterruptMode(gpio_pins::KEY_NOT_PRESENT));
}

void test_key_sensor_interrupt_simulation() {
    // Given: Initialized sensor with key not present
    TestHelpers::configureMockForKeySensor(mockGpio.get(), false, true);
    sensor->init();
    KeyState initialState = sensor->getKeyState();
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::NotPresent), static_cast<int>(initialState));
    
    // When: Key present pin changes (simulating interrupt)
    mockGpio->simulateDigitalChange(gpio_pins::KEY_PRESENT, true);
    mockGpio->simulateDigitalChange(gpio_pins::KEY_NOT_PRESENT, false);
    
    // Then: State should reflect the change
    KeyState newState = sensor->getKeyState();
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::Present), static_cast<int>(newState));
}

// ============================================================================
// EDGE CASE TESTS
// ============================================================================

void test_key_sensor_rapid_state_changes() {
    // Test rapid state changes to verify stability
    sensor->init();
    
    // Simulate rapid pin changes
    TestHelpers::configureMockForKeySensor(mockGpio.get(), true, false);
    KeyState state1 = sensor->getKeyState();
    
    TestHelpers::configureMockForKeySensor(mockGpio.get(), false, true);
    KeyState state2 = sensor->getKeyState();
    
    TestHelpers::configureMockForKeySensor(mockGpio.get(), false, false);
    KeyState state3 = sensor->getKeyState();
    
    TestHelpers::configureMockForKeySensor(mockGpio.get(), true, true);
    KeyState state4 = sensor->getKeyState();
    
    // Verify each state is correct
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::Present), static_cast<int>(state1));
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::NotPresent), static_cast<int>(state2));
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::Inactive), static_cast<int>(state3));
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::Inactive), static_cast<int>(state4));
}

void test_key_sensor_debouncing_behavior() {
    // Test that sensor handles bouncing inputs gracefully
    sensor->init();
    
    // Simulate bouncing input (rapid changes)
    for (int i = 0; i < 10; i++) {
        bool pinState = (i % 2 == 0);
        TestHelpers::configureMockForKeySensor(mockGpio.get(), pinState, false);
        KeyState state = sensor->getKeyState();
        
        // State should correspond to current pin reading
        KeyState expectedState = pinState ? KeyState::Present : KeyState::Inactive;
        TEST_ASSERT_EQUAL_INT(static_cast<int>(expectedState), static_cast<int>(state));
    }
}

void test_key_sensor_invalid_state_handling() {
    // Test behavior when both pins are HIGH (should not happen in real hardware)
    TestHelpers::configureMockForKeySensor(mockGpio.get(), true, true);
    sensor->init();
    
    // Should gracefully handle by returning Inactive
    KeyState state = sensor->getKeyState();
    Reading reading = sensor->getReading();
    
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::Inactive), static_cast<int>(state));
    TEST_ASSERT_EQUAL_INT32(static_cast<int32_t>(KeyState::Inactive), std::get<int32_t>(reading));
}

// ============================================================================
// CONSISTENCY TESTS
// ============================================================================

void test_key_sensor_getReading_vs_getKeyState_consistency() {
    // Test that getReading() and getKeyState() return consistent values
    
    // Test all valid states
    std::vector<std::pair<bool, bool>> testStates = {
        {true, false},   // Present
        {false, true},   // NotPresent  
        {false, false},  // Inactive
        {true, true}     // Invalid -> Inactive
    };
    
    sensor->init();
    
    for (const auto& [present, notPresent] : testStates) {
        TestHelpers::configureMockForKeySensor(mockGpio.get(), present, notPresent);
        
        Reading reading = sensor->getReading();
        KeyState directState = sensor->getKeyState();
        
        // Both methods should return the same state value
        TEST_ASSERT_TRUE(std::holds_alternative<int32_t>(reading));
        TEST_ASSERT_EQUAL_INT32(static_cast<int32_t>(directState), std::get<int32_t>(reading));
    }
}

void test_key_sensor_multiple_readings_same_state() {
    // Test that multiple readings with same pin state return consistent results
    TestHelpers::configureMockForKeySensor(mockGpio.get(), true, false);
    sensor->init();
    
    // Take multiple readings
    std::vector<KeyState> states;
    std::vector<Reading> readings;
    
    for (int i = 0; i < 5; i++) {
        states.push_back(sensor->getKeyState());
        readings.push_back(sensor->getReading());
    }
    
    // All should be identical
    for (size_t i = 1; i < states.size(); i++) {
        TEST_ASSERT_EQUAL_INT(static_cast<int>(states[0]), static_cast<int>(states[i]));
        TEST_ASSERT_EQUAL_INT32(std::get<int32_t>(readings[0]), std::get<int32_t>(readings[i]));
    }
}

// ============================================================================
// PERFORMANCE TESTS
// ============================================================================

void test_key_sensor_performance_reading_speed() {
    // Given: Initialized sensor
    TestHelpers::configureMockForKeySensor(mockGpio.get(), true, false);
    sensor->init();
    
    // When: Multiple rapid readings are taken
    auto start = std::chrono::steady_clock::now();
    
    for (int i = 0; i < 100; i++) {
        Reading reading = sensor->getReading();
        TEST_ASSERT_TRUE(std::holds_alternative<int32_t>(reading));
    }
    
    auto end = std::chrono::steady_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    
    // Then: Should complete quickly (< 1ms total for 100 reads)
    TEST_ASSERT_TRUE(duration.count() < 1000); // Less than 1ms
}

void test_key_sensor_memory_usage() {
    // Verify no memory leaks during operation
    TEST_ASSERT_NO_MEMORY_LEAK();
    
    // Create and destroy multiple sensors
    for (int i = 0; i < 10; i++) {
        auto testMock = TestHelpers::createMockGpioProvider();
        KeySensor testSensor(testMock.get());
        testSensor.init();
        testSensor.getReading();
        testSensor.getKeyState();
    }
    
    TEST_ASSERT_NO_MEMORY_LEAK();
}

// ============================================================================
// INTEGRATION TESTS
// ============================================================================

void test_key_sensor_realistic_scenario() {
    // Simulate realistic key insertion/removal scenario
    sensor->init();
    
    // Initial state: No key
    TestHelpers::configureMockForKeySensor(mockGpio.get(), false, false);
    KeyState noKeyState = sensor->getKeyState();
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::Inactive), static_cast<int>(noKeyState));
    
    // Key removed explicitly
    TestHelpers::configureMockForKeySensor(mockGpio.get(), false, true);
    KeyState removedState = sensor->getKeyState();
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::NotPresent), static_cast<int>(removedState));
    
    // Key inserted
    TestHelpers::configureMockForKeySensor(mockGpio.get(), true, false);
    KeyState insertedState = sensor->getKeyState();
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::Present), static_cast<int>(insertedState));
    
    // Key turned off (back to inactive)
    TestHelpers::configureMockForKeySensor(mockGpio.get(), false, false);
    KeyState offState = sensor->getKeyState();
    TEST_ASSERT_EQUAL_INT(static_cast<int>(KeyState::Inactive), static_cast<int>(offState));
}

void test_key_sensor_multiple_initialization() {
    // Test that multiple init() calls don't cause issues
    sensor->init();
    KeyState state1 = sensor->getKeyState();
    
    sensor->init(); // Second initialization
    KeyState state2 = sensor->getKeyState();
    
    // Should still work correctly and consistently
    TEST_ASSERT_EQUAL_INT(static_cast<int>(state1), static_cast<int>(state2));
}

// ============================================================================
// TEST RUNNER SETUP
// ============================================================================

void runKeySensorTests() {
    RUN_TEST(test_key_sensor_initialization);
    RUN_TEST(test_key_sensor_constructor);
    RUN_TEST(test_key_sensor_interrupt_configuration);
    
    RUN_TEST(test_key_sensor_key_present_state);
    RUN_TEST(test_key_sensor_key_not_present_state);
    RUN_TEST(test_key_sensor_inactive_state_both_low);
    RUN_TEST(test_key_sensor_inactive_state_both_high);
    
    RUN_TEST(test_key_sensor_state_transitions_present_to_not_present);
    RUN_TEST(test_key_sensor_state_transitions_not_present_to_present);
    RUN_TEST(test_key_sensor_state_transitions_to_inactive);
    RUN_TEST(test_key_sensor_state_transitions_from_inactive);
    
    RUN_TEST(test_key_sensor_gpio_pin_usage);
    RUN_TEST(test_key_sensor_pin_mode_configuration);
    
    RUN_TEST(test_key_sensor_interrupt_setup);
    RUN_TEST(test_key_sensor_interrupt_simulation);
    
    RUN_TEST(test_key_sensor_rapid_state_changes);
    RUN_TEST(test_key_sensor_debouncing_behavior);
    RUN_TEST(test_key_sensor_invalid_state_handling);
    
    RUN_TEST(test_key_sensor_getReading_vs_getKeyState_consistency);
    RUN_TEST(test_key_sensor_multiple_readings_same_state);
    
    RUN_TEST(test_key_sensor_performance_reading_speed);
    RUN_TEST(test_key_sensor_memory_usage);
    
    RUN_TEST(test_key_sensor_realistic_scenario);
    RUN_TEST(test_key_sensor_multiple_initialization);
}

#ifdef UNITY_MAIN
int main() {
    UNITY_BEGIN();
    runKeySensorTests();
    return UNITY_END();
}
#endif