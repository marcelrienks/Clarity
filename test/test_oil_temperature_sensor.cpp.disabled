/**
 * @file test_oil_temperature_sensor.cpp
 * @brief Comprehensive unit tests for OilTemperatureSensor class
 * 
 * @details Tests all aspects of oil temperature sensor functionality including:
 * - Initialization and configuration
 * - ADC value to temperature mapping (0-4095 → 0-120°C)
 * - Delta-based updates (only on value change)
 * - Time-based sampling (1Hz frequency)
 * - Boundary conditions and error handling
 * - Temperature-specific validation ranges
 * 
 * Success Criteria:
 * - 100% test pass rate
 * - All boundary conditions covered
 * - Delta-based update behavior verified
 * - Time-based sampling validated
 * - Hardware abstraction properly tested
 */

#include "unity.h"
#include "unity_config.h"
#include "sensors/oil_temperature_sensor.h"
#include "mocks/mock_gpio_provider.h"
#include "utilities/test_helpers.h"
#include "hardware/gpio_pins.h"
#include <memory>
#include <thread>
#include <chrono>

// Test fixture globals
static std::unique_ptr<MockGpioProvider> mockGpio;
static std::unique_ptr<OilTemperatureSensor> sensor;

void setUp(void) {
    // Create fresh mock and sensor for each test
    mockGpio = TestHelpers::createMockGpioProvider();
    sensor = std::make_unique<OilTemperatureSensor>(mockGpio.get());
}

void tearDown(void) {
    // Clean up after each test
    sensor.reset();
    mockGpio.reset();
}

// ============================================================================
// INITIALIZATION TESTS
// ============================================================================

void test_oil_temperature_sensor_initialization() {
    // Given: Fresh sensor and mock
    // When: Sensor is initialized
    sensor->init();
    
    // Then: No crashes occur and sensor is ready
    Reading reading = sensor->getReading();
    TEST_ASSERT_FALSE(std::holds_alternative<std::monostate>(reading));
    
    // Verify GPIO configuration was called
    TEST_ASSERT_TRUE(mockGpio->getAnalogReadCount(gpio_pins::OIL_TEMPERATURE) > 0);
}

void test_oil_temperature_sensor_constructor() {
    // Given: Valid GPIO provider
    // When: Sensor is constructed
    OilTemperatureSensor testSensor(mockGpio.get());
    
    // Then: Construction succeeds without throwing
    TEST_ASSERT_NOT_NULL(&testSensor);
}

// ============================================================================
// ADC VALUE MAPPING TESTS
// ============================================================================

void test_oil_temperature_sensor_adc_mapping_minimum() {
    // Given: ADC value at minimum (0)
    TestHelpers::configureMockForOilTemperature(mockGpio.get(), 0);
    sensor->init();
    
    // When: Reading is obtained
    Reading reading = sensor->getReading();
    
    // Then: Temperature should be 0°C
    int32_t expectedTemperature = TestHelpers::calculateExpectedTemperature(0);
    TestHelpers::assertReadingInt32(reading, expectedTemperature);
    TEST_ASSERT_EQUAL_INT32(0, expectedTemperature);
}

void test_oil_temperature_sensor_adc_mapping_maximum() {
    // Given: ADC value at maximum (4095)
    TestHelpers::configureMockForOilTemperature(mockGpio.get(), 4095);
    sensor->init();
    
    // When: Reading is obtained
    Reading reading = sensor->getReading();
    
    // Then: Temperature should be 120°C
    int32_t expectedTemperature = TestHelpers::calculateExpectedTemperature(4095);
    TestHelpers::assertReadingInt32(reading, expectedTemperature);
    TEST_ASSERT_EQUAL_INT32(120, expectedTemperature);
}

void test_oil_temperature_sensor_adc_mapping_midpoint() {
    // Given: ADC value at midpoint (2048)
    uint16_t midpointAdc = 2048;
    TestHelpers::configureMockForOilTemperature(mockGpio.get(), midpointAdc);
    sensor->init();
    
    // When: Reading is obtained
    Reading reading = sensor->getReading();
    
    // Then: Temperature should be approximately 60°C
    int32_t expectedTemperature = TestHelpers::calculateExpectedTemperature(midpointAdc);
    TestHelpers::assertReadingInt32(reading, expectedTemperature);
    TestHelpers::assertValidTemperatureRange(expectedTemperature);
    
    // Verify it's close to expected midpoint (within ±1 due to integer math)
    TEST_ASSERT_TRUE(expectedTemperature >= 59 && expectedTemperature <= 61);
}

void test_oil_temperature_sensor_adc_mapping_quarter_points() {
    // Test quarter points to verify linear mapping
    
    // First quarter (25%)
    uint16_t quarterAdc = 1024;  // 25% of 4095
    TestHelpers::configureMockForOilTemperature(mockGpio.get(), quarterAdc);
    sensor->init();
    Reading reading1 = sensor->getReading();
    int32_t temperature1 = std::get<int32_t>(reading1);
    TestHelpers::assertValidTemperatureRange(temperature1);
    
    // Third quarter (75%)
    uint16_t threeQuarterAdc = 3072;  // 75% of 4095
    mockGpio->setAnalogReading(gpio_pins::OIL_TEMPERATURE, threeQuarterAdc);
    TestHelpers::waitForSensorUpdate(1000);
    Reading reading2 = sensor->getReading();
    int32_t temperature2 = std::get<int32_t>(reading2);
    TestHelpers::assertValidTemperatureRange(temperature2);
    
    // Verify linear relationship (temperature2 should be ~3x temperature1)
    TEST_ASSERT_TRUE(temperature2 > temperature1);
}

// ============================================================================
// DELTA-BASED UPDATE TESTS
// ============================================================================

void test_oil_temperature_sensor_delta_based_updates_same_value() {
    // Given: Sensor initialized with specific ADC value
    uint16_t adcValue = 2048;
    TestHelpers::configureMockForOilTemperature(mockGpio.get(), adcValue);
    sensor->init();
    
    // When: Multiple readings are taken without changing ADC value
    Reading reading1 = sensor->getReading();
    Reading reading2 = sensor->getReading();
    Reading reading3 = sensor->getReading();
    
    // Then: All readings should be identical
    int32_t temperature1 = std::get<int32_t>(reading1);
    int32_t temperature2 = std::get<int32_t>(reading2);
    int32_t temperature3 = std::get<int32_t>(reading3);
    
    TEST_ASSERT_EQUAL_INT32(temperature1, temperature2);
    TEST_ASSERT_EQUAL_INT32(temperature2, temperature3);
}

void test_oil_temperature_sensor_delta_based_updates_value_change() {
    // Given: Sensor initialized with initial ADC value (cold temperature)
    TestHelpers::configureMockForOilTemperature(mockGpio.get(), 1000);
    sensor->init();
    Reading initialReading = sensor->getReading();
    int32_t initialTemperature = std::get<int32_t>(initialReading);
    
    // When: ADC value changes (warmer temperature) and sufficient time passes
    mockGpio->setAnalogReading(gpio_pins::OIL_TEMPERATURE, 3000);
    TestHelpers::waitForSensorUpdate(1000);
    
    // Then: New reading should reflect changed value
    Reading newReading = sensor->getReading();
    int32_t newTemperature = std::get<int32_t>(newReading);
    
    TEST_ASSERT_NOT_EQUAL(initialTemperature, newTemperature);
    TEST_ASSERT_TRUE(newTemperature > initialTemperature);
}

void test_oil_temperature_sensor_delta_based_updates_no_time_passage() {
    // Given: Sensor initialized
    TestHelpers::configureMockForOilTemperature(mockGpio.get(), 1000);
    sensor->init();
    Reading initialReading = sensor->getReading();
    
    // When: ADC value changes but insufficient time passes
    mockGpio->setAnalogReading(gpio_pins::OIL_TEMPERATURE, 3000);
    // No time advancement - should use cached value
    
    // Then: Reading should still be cached value
    Reading quickReading = sensor->getReading();
    
    TEST_ASSERT_EQUAL_INT32(std::get<int32_t>(initialReading), 
                           std::get<int32_t>(quickReading));
}

// ============================================================================
// TIME-BASED SAMPLING TESTS
// ============================================================================

void test_oil_temperature_sensor_time_based_sampling_frequency() {
    // Given: Sensor with gradually increasing temperature values
    std::vector<uint16_t> adcSequence = {1000, 1500, 2000, 2500, 3000};
    mockGpio->setAnalogReadingSequence(gpio_pins::OIL_TEMPERATURE, adcSequence);
    sensor->init();
    
    // When: Readings are taken at update intervals
    std::vector<int32_t> temperatureReadings;
    
    for (int i = 0; i < 5; i++) {
        Reading reading = sensor->getReading();
        temperatureReadings.push_back(std::get<int32_t>(reading));
        
        if (i < 4) { // Don't wait after last reading
            TestHelpers::waitForSensorUpdate(1000);
        }
    }
    
    // Then: Each reading should be different (following the sequence)
    for (size_t i = 1; i < temperatureReadings.size(); i++) {
        TEST_ASSERT_NOT_EQUAL(temperatureReadings[i-1], temperatureReadings[i]);
        // Each should be higher than previous (increasing sequence)
        TEST_ASSERT_TRUE(temperatureReadings[i] > temperatureReadings[i-1]);
    }
}

void test_oil_temperature_sensor_time_based_sampling_update_interval() {
    // Given: Sensor initialized
    TestHelpers::configureMockForOilTemperature(mockGpio.get(), 1500);
    sensor->init();
    
    // Record initial read count
    int initialReadCount = mockGpio->getAnalogReadCount(gpio_pins::OIL_TEMPERATURE);
    
    // When: Multiple readings are requested rapidly (< 1000ms apart)
    sensor->getReading();
    sensor->getReading();
    sensor->getReading();
    
    // Then: GPIO should not be read multiple times (caching)
    int rapidReadCount = mockGpio->getAnalogReadCount(gpio_pins::OIL_TEMPERATURE);
    TEST_ASSERT_EQUAL_INT(initialReadCount, rapidReadCount);
    
    // When: Sufficient time passes and reading is requested
    TestHelpers::waitForSensorUpdate(1000);
    sensor->getReading();
    
    // Then: GPIO should be read again
    int delayedReadCount = mockGpio->getAnalogReadCount(gpio_pins::OIL_TEMPERATURE);
    TEST_ASSERT_TRUE(delayedReadCount > rapidReadCount);
}

// ============================================================================
// BOUNDARY CONDITION TESTS
// ============================================================================

void test_oil_temperature_sensor_boundary_adc_zero() {
    // Test explicit zero ADC value
    TestHelpers::configureMockForOilTemperature(mockGpio.get(), 0);
    sensor->init();
    
    Reading reading = sensor->getReading();
    int32_t temperature = std::get<int32_t>(reading);
    
    TEST_ASSERT_EQUAL_INT32(0, temperature);
    TestHelpers::assertValidTemperatureRange(temperature);
}

void test_oil_temperature_sensor_boundary_adc_max() {
    // Test maximum ADC value
    TestHelpers::configureMockForOilTemperature(mockGpio.get(), 4095);
    sensor->init();
    
    Reading reading = sensor->getReading();
    int32_t temperature = std::get<int32_t>(reading);
    
    TEST_ASSERT_EQUAL_INT32(120, temperature);
    TestHelpers::assertValidTemperatureRange(temperature);
}

void test_oil_temperature_sensor_boundary_temperature_ranges() {
    // Test various temperature ranges to ensure all are valid
    std::vector<uint16_t> testAdcValues = {0, 341, 682, 1023, 1365, 2047, 2730, 3071, 3413, 3754, 4095};
    
    for (uint16_t adcValue : testAdcValues) {
        mockGpio->setAnalogReading(gpio_pins::OIL_TEMPERATURE, adcValue);
        TestHelpers::waitForSensorUpdate(1000);
        
        Reading reading = sensor->getReading();
        int32_t temperature = std::get<int32_t>(reading);
        
        TestHelpers::assertValidTemperatureRange(temperature);
        
        // Verify temperature correlates with ADC value
        int32_t expectedTemperature = TestHelpers::calculateExpectedTemperature(adcValue);
        TEST_ASSERT_EQUAL_INT32(expectedTemperature, temperature);
    }
}

// ============================================================================
// TEMPERATURE-SPECIFIC TESTS
// ============================================================================

void test_oil_temperature_sensor_cold_engine_conditions() {
    // Test cold engine conditions (0-20°C)
    uint16_t coldAdcValue = 683;  // Should result in ~20°C
    TestHelpers::configureMockForOilTemperature(mockGpio.get(), coldAdcValue);
    sensor->init();
    
    Reading reading = sensor->getReading();
    int32_t temperature = std::get<int32_t>(reading);
    
    TEST_ASSERT_TRUE(temperature >= 19 && temperature <= 21); // Allow ±1°C tolerance
    TestHelpers::assertValidTemperatureRange(temperature);
}

void test_oil_temperature_sensor_normal_operating_conditions() {
    // Test normal operating conditions (80-100°C)
    uint16_t normalAdcValue = 3413;  // Should result in ~100°C
    TestHelpers::configureMockForOilTemperature(mockGpio.get(), normalAdcValue);
    sensor->init();
    
    Reading reading = sensor->getReading();
    int32_t temperature = std::get<int32_t>(reading);
    
    TEST_ASSERT_TRUE(temperature >= 99 && temperature <= 101); // Allow ±1°C tolerance
    TestHelpers::assertValidTemperatureRange(temperature);
}

void test_oil_temperature_sensor_overheating_conditions() {
    // Test overheating conditions (110-120°C)
    uint16_t hotAdcValue = 3754;  // Should result in ~110°C
    TestHelpers::configureMockForOilTemperature(mockGpio.get(), hotAdcValue);
    sensor->init();
    
    Reading reading = sensor->getReading();
    int32_t temperature = std::get<int32_t>(reading);
    
    TEST_ASSERT_TRUE(temperature >= 109 && temperature <= 111); // Allow ±1°C tolerance
    TestHelpers::assertValidTemperatureRange(temperature);
    
    // Verify this is in warning range
    TEST_ASSERT_TRUE(temperature >= 100); // Above normal operating range
}

// ============================================================================
// ERROR CONDITION TESTS
// ============================================================================

void test_oil_temperature_sensor_gpio_pin_validation() {
    // Verify sensor uses correct GPIO pin
    sensor->init();
    sensor->getReading();
    
    // Should have read from oil temperature pin
    TEST_ASSERT_TRUE(mockGpio->getAnalogReadCount(gpio_pins::OIL_TEMPERATURE) > 0);
    
    // Should not have read from other pins
    TEST_ASSERT_EQUAL_INT(0, mockGpio->getAnalogReadCount(gpio_pins::OIL_PRESSURE));
    TEST_ASSERT_EQUAL_INT(0, mockGpio->getDigitalReadCount(gpio_pins::KEY_PRESENT));
}

void test_oil_temperature_sensor_multiple_initialization() {
    // Test that multiple init() calls don't cause issues
    sensor->init();
    Reading reading1 = sensor->getReading();
    
    sensor->init(); // Second initialization
    Reading reading2 = sensor->getReading();
    
    // Should still work correctly
    TEST_ASSERT_TRUE(std::holds_alternative<int32_t>(reading1));
    TEST_ASSERT_TRUE(std::holds_alternative<int32_t>(reading2));
}

// ============================================================================
// PERFORMANCE TESTS
// ============================================================================

void test_oil_temperature_sensor_performance_reading_speed() {
    // Given: Initialized sensor
    TestHelpers::configureMockForOilTemperature(mockGpio.get(), 2048);
    sensor->init();
    
    // When: Multiple rapid readings are taken (should use cache)
    auto start = std::chrono::steady_clock::now();
    
    for (int i = 0; i < 100; i++) {
        Reading reading = sensor->getReading();
        TEST_ASSERT_TRUE(std::holds_alternative<int32_t>(reading));
    }
    
    auto end = std::chrono::steady_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    
    // Then: Should complete quickly (< 1ms total for 100 reads due to caching)
    TEST_ASSERT_TRUE(duration.count() < 1000); // Less than 1ms
}

void test_oil_temperature_sensor_memory_usage() {
    // Verify no memory leaks during operation
    TEST_ASSERT_NO_MEMORY_LEAK();
    
    // Create and destroy multiple sensors
    for (int i = 0; i < 10; i++) {
        auto testMock = TestHelpers::createMockGpioProvider();
        OilTemperatureSensor testSensor(testMock.get());
        testSensor.init();
        testSensor.getReading();
    }
    
    TEST_ASSERT_NO_MEMORY_LEAK();
}

// ============================================================================
// INTEGRATION TESTS
// ============================================================================

void test_oil_temperature_sensor_realistic_scenario() {
    // Simulate realistic oil temperature changes during engine operation
    
    // Engine start: Cold temperature
    TestHelpers::configureMockForOilTemperature(mockGpio.get(), 683); // ~20°C
    sensor->init();
    Reading startReading = sensor->getReading();
    int32_t startTemperature = std::get<int32_t>(startReading);
    TEST_ASSERT_TRUE(startTemperature >= 15 && startTemperature <= 25);
    
    // Engine warm-up: Gradually increasing temperature
    mockGpio->setAnalogReading(gpio_pins::OIL_TEMPERATURE, 1707); // ~50°C
    TestHelpers::waitForSensorUpdate(1000);
    Reading warmupReading = sensor->getReading();
    int32_t warmupTemperature = std::get<int32_t>(warmupReading);
    TEST_ASSERT_TRUE(warmupTemperature > startTemperature);
    
    // Normal operation: Stable operating temperature
    mockGpio->setAnalogReading(gpio_pins::OIL_TEMPERATURE, 2730); // ~80°C
    TestHelpers::waitForSensorUpdate(1000);
    Reading normalReading = sensor->getReading();
    int32_t normalTemperature = std::get<int32_t>(normalReading);
    TEST_ASSERT_TRUE(normalTemperature > warmupTemperature);
    TEST_ASSERT_TRUE(normalTemperature >= 75 && normalTemperature <= 85);
}

void test_oil_temperature_sensor_thermal_lag_simulation() {
    // Temperature changes more slowly than pressure - simulate thermal lag
    
    // Initial temperature
    TestHelpers::configureMockForOilTemperature(mockGpio.get(), 1365); // ~40°C
    sensor->init();
    Reading reading1 = sensor->getReading();
    
    // Small incremental changes (thermal lag effect)
    std::vector<uint16_t> gradualChanges = {1365, 1400, 1450, 1500, 1550};
    mockGpio->setAnalogReadingSequence(gpio_pins::OIL_TEMPERATURE, gradualChanges);
    
    std::vector<int32_t> temperatures;
    for (size_t i = 0; i < gradualChanges.size(); i++) {
        TestHelpers::waitForSensorUpdate(1000);
        Reading reading = sensor->getReading();
        temperatures.push_back(std::get<int32_t>(reading));
    }
    
    // Verify gradual increase
    for (size_t i = 1; i < temperatures.size(); i++) {
        TEST_ASSERT_TRUE(temperatures[i] >= temperatures[i-1]); // Non-decreasing
        // Change should be small (< 5°C per step)
        TEST_ASSERT_TRUE((temperatures[i] - temperatures[i-1]) <= 5);
    }
}

// ============================================================================
// TEST RUNNER SETUP
// ============================================================================

void runOilTemperatureSensorTests() {
    RUN_TEST(test_oil_temperature_sensor_initialization);
    RUN_TEST(test_oil_temperature_sensor_constructor);
    
    RUN_TEST(test_oil_temperature_sensor_adc_mapping_minimum);
    RUN_TEST(test_oil_temperature_sensor_adc_mapping_maximum);
    RUN_TEST(test_oil_temperature_sensor_adc_mapping_midpoint);
    RUN_TEST(test_oil_temperature_sensor_adc_mapping_quarter_points);
    
    RUN_TEST(test_oil_temperature_sensor_delta_based_updates_same_value);
    RUN_TEST(test_oil_temperature_sensor_delta_based_updates_value_change);
    RUN_TEST(test_oil_temperature_sensor_delta_based_updates_no_time_passage);
    
    RUN_TEST(test_oil_temperature_sensor_time_based_sampling_frequency);
    RUN_TEST(test_oil_temperature_sensor_time_based_sampling_update_interval);
    
    RUN_TEST(test_oil_temperature_sensor_boundary_adc_zero);
    RUN_TEST(test_oil_temperature_sensor_boundary_adc_max);
    RUN_TEST(test_oil_temperature_sensor_boundary_temperature_ranges);
    
    RUN_TEST(test_oil_temperature_sensor_cold_engine_conditions);
    RUN_TEST(test_oil_temperature_sensor_normal_operating_conditions);
    RUN_TEST(test_oil_temperature_sensor_overheating_conditions);
    
    RUN_TEST(test_oil_temperature_sensor_gpio_pin_validation);
    RUN_TEST(test_oil_temperature_sensor_multiple_initialization);
    
    RUN_TEST(test_oil_temperature_sensor_performance_reading_speed);
    RUN_TEST(test_oil_temperature_sensor_memory_usage);
    
    RUN_TEST(test_oil_temperature_sensor_realistic_scenario);
    RUN_TEST(test_oil_temperature_sensor_thermal_lag_simulation);
}

#ifdef UNITY_MAIN
int main() {
    UNITY_BEGIN();
    runOilTemperatureSensorTests();
    return UNITY_END();
}
#endif